/*var collidingX = false;
            var collidingY = false;

            m_ColliderCheck = new Rectangle((int)(Position.X - m_SpriteHalf.X / 2), (int)(Position.Y - m_SpriteHalf.Y / 2), 8, 8);

            

            foreach(Rectangle wall in walls) {

                if (m_ColliderCheck.Intersects(wall)) {
                    if(body.Magnitude.X != 0) collidingX = true;
                    if(body.Magnitude.Y != 0) collidingY = true;
                }              
            }

            if (collidingX && !collidingY) {
                
            }

            if(collidingY && !collidingX) {
                
            }
            */

                   /*private Vector2? OnWallCollision(List<Rectangle> walls) {

            bool collidingX = false;
            bool collidingY = false;

            bool Ecolliding = false;
            bool Ncolliding = false;
            bool Wcolliding = false;
            bool Scolliding = false;

            m_ColliderCheck = new Rectangle((int)(Position.X - m_SpriteHalf.X / 2), (int)(Position.Y - m_SpriteHalf.Y / 2), 9, 9);
          
            if (body.Magnitude.X > 0) {
                m_ColliderCheck.Location = new Point(m_ColliderCheck.Location.X + (int)Globals.TileSize.X / 4, m_ColliderCheck.Location.Y);
            } else if (body.Magnitude.X < 0) {
                m_ColliderCheck.Location = new Point(m_ColliderCheck.Location.X - (int)Globals.TileSize.X / 4 - 1, m_ColliderCheck.Location.Y);
            }

            if (body.Magnitude.Y < 0) {
                m_ColliderCheck.Location = new Point(m_ColliderCheck.Location.X, m_ColliderCheck.Location.Y - (int)Globals.TileSize.Y / 4 - 1);
            } else if (body.Magnitude.Y > 0) {
                m_ColliderCheck.Location = new Point(m_ColliderCheck.Location.X, m_ColliderCheck.Location.Y + (int)Globals.TileSize.Y / 4);
            }

            m_EWallDirectionCheck = new Rectangle(m_ColliderCheck.Location.X + m_ColliderCheck.Width / 2,     m_ColliderCheck.Location.Y + m_ColliderCheck.Height / 2,     6, 1);
            m_NWallDirectionCheck = new Rectangle(m_ColliderCheck.Location.X + m_ColliderCheck.Width / 2,     m_ColliderCheck.Location.Y - 5 + m_ColliderCheck.Height / 2, 1, 5);
            m_WWallDirectionCheck = new Rectangle(m_ColliderCheck.Location.X - 5 + m_ColliderCheck.Width / 2, m_ColliderCheck.Location.Y + m_ColliderCheck.Height / 2,     5, 1);
            m_SWallDirectionCheck = new Rectangle(m_ColliderCheck.Location.X + m_ColliderCheck.Width / 2,     m_ColliderCheck.Location.Y + m_ColliderCheck.Height / 2,     1, 6);

            foreach (Rectangle wall in walls) {
                if (m_ColliderCheck.Intersects(wall)) {
                    if(body.Magnitude.X != 0) collidingX = true;
                    if(body.Magnitude.Y != 0) collidingY = true;
                }

                if (m_EWallDirectionCheck.Intersects(wall)) Ecolliding = true;
                if (m_NWallDirectionCheck.Intersects(wall)) Ncolliding = true;
                if (m_WWallDirectionCheck.Intersects(wall)) Wcolliding = true;
                if (m_SWallDirectionCheck.Intersects(wall)) Scolliding = true;

                //if(Vcolliding && Hcolliding) Bcolliding = true;

            }

            if(collidingX && collidingY) {
                //Up Right Vector (1, -1)
                if(body.Magnitude.X > 0 && body.Magnitude.Y < 0) {
                    if(Ecolliding && !Ncolliding)
                        return HandleVerticalWallSliding(body.Magnitude.X);
                    if(Ncolliding && !Ecolliding)
                        return HandleHorizontalWallSliding(body.Magnitude.Y);
                }

                //Up Left Vector (-1, -1)
                if (body.Magnitude.X < 0 && body.Magnitude.Y < 0) {
                    if(Wcolliding && !Ncolliding)
                        return HandleVerticalWallSliding(body.Magnitude.X);
                    if(Ncolliding && !Wcolliding)
                        return HandleHorizontalWallSliding(body.Magnitude.Y);
                }

                //Down Right Vector (1, 1)
                if (body.Magnitude.X > 0 && body.Magnitude.Y > 0) {
                    if(Ecolliding && !Scolliding)
                        return HandleVerticalWallSliding(body.Magnitude.X);
                    if(Scolliding && !Ecolliding)
                        return HandleHorizontalWallSliding(body.Magnitude.Y);
                }

                //Down Left Vector (-1, 1)
                if (body.Magnitude.X < 0 && body.Magnitude.Y > 0) {
                    if (Wcolliding && !Scolliding)
                        return HandleVerticalWallSliding(body.Magnitude.X);
                    if (Scolliding && !Wcolliding)
                        return HandleHorizontalWallSliding(body.Magnitude.Y);
                }
            }

            if (collidingX || collidingY) {
                Vector2 newPos = Position;

                if (collidingX) {
                    newPos = new Vector2((float)HandleHorizontalCollision(), newPos.Y);
                }

                if(collidingY) {
                    newPos = new Vector2(newPos.X, (float)HandleVerticalCollision());
                }

                return newPos;
            }

            return null;

        }*/
        
        /*private float HandleHorizontalCollision() {

            switch (body.Magnitude.X) {
                case 1:
                    var x = Position.X;
                    var newX = x - (x % Globals.TileSize.X) + Globals.TileSize.X - (m_SpriteHalf.X - 1) - 1;
                    return newX;
                case -1:
                    var leftx = Position.X;
                    var leftnewX = leftx - (leftx % Globals.TileSize.X) + (m_SpriteHalf.X - 1) + 1;
                    return leftnewX;
            }

            return Position.X;
        }

        private float HandleVerticalCollision() {
            switch (body.Magnitude.Y) {
                case 1:
                    var upy = Position.Y;
                    var upnewY = upy - (upy % Globals.TileSize.Y) + (m_SpriteHalf.Y + 1) - 1;
                    return upnewY;
                case -1:
                    var downY = Position.Y;
                    var downnewY = downY - (downY % Globals.TileSize.Y) + Globals.TileSize.Y - (m_SpriteHalf.Y + 1) + 1;
                    return downnewY;
            }

            return Position.Y;
        }*/